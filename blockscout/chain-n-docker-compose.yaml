volumes:
  redis-data:
  logs:
  dets:

networks:
  default:
    driver: bridge

  proxy-network:
    external: true
    name: proxy-network  

  service-network:
    external: true
    name: service-network

services:
  redis-db:
    extends:
      file: ./services/redis.yml
      service: redis-db
    networks:
      - default   
      

  create-blockscout-db:
    extends:
      file: ./services/create-db.yml
      service: create-blockscout-db
    networks:
      - service-network  

  create-stats-db:
    extends:
      file: ./services/create-db.yml
      service: create-stats-db
    networks:
      - service-network     

      

  backend:
    depends_on:
      redis-db:
        condition: service_started
      create-blockscout-db : 
          condition: service_completed_successfully  
    extends:
      file: ./services/backend.yml
      service: backend   
    environment:
      - CHAIN_ID=${CHAIN_ID}
      - SUBNETWORK=${SUBNETWORK}
      - ETHEREUM_JSONRPC_HTTP_URL=${ETHEREUM_JSONRPC_HTTP_URL}
      - ETHEREUM_JSONRPC_WS_URL=${ETHEREUM_JSONRPC_WS_URL}
      - ETHEREUM_JSONRPC_TRACE_URL=${ETHEREUM_JSONRPC_TRACE_URL}
      - DATABASE_URL=${DATABASE_URL}
    networks:
      - proxy-network
      - service-network 
      - default
    labels:
      caddy.@match_backend: "expression path_regexp('^/(api($|/)|socket|sitemap.xml|auth/auth0|auth/auth0/callback|auth/logout)')"
      caddy: chain-${CHAINWEB_CHAIN_ID}.${BASE_EXPLORER_DOMAIN}
      caddy.handle: "@match_backend"
      caddy.handle.reverse_proxy: "{{ upstreams 4000 }}"

  frontend:
    depends_on:
      - backend
    extends:
      file: ./services/frontend.yml
      service: frontend
    volumes:
      - ./logs/frontend:/app/logs
      - ./assets:/assets
    environment:
      - NEXT_PUBLIC_NETWORK_ID=${NEXT_PUBLIC_NETWORK_ID?}

      # Kinda sucks. Why does this communicate via the host network? 
      # I think because this urls will be used in the browser so they should target the host not the container
      - NEXT_PUBLIC_STATS_API_HOST=${NEXT_PUBLIC_STATS_API_HOST}
      - NEXT_PUBLIC_VISUALIZE_API_HOST=${NEXT_PUBLIC_VISUALIZE_API_HOST}
      - NEXT_PUBLIC_APP_HOST=${NEXT_PUBLIC_APP_HOST}
      - NEXT_PUBLIC_APP_PORT=${NEXT_PUBLIC_APP_PORT}
      - NEXT_PUBLIC_API_HOST=${NEXT_PUBLIC_API_HOST}
      - NEXT_PUBLIC_API_PORT=${NEXT_PUBLIC_API_PORT}
      - NEXT_PUBLIC_NETWORK_NAME=${NEXT_PUBLIC_NETWORK_NAME}
      - NEXT_PUBLIC_NETWORK_RPC_URL=${NEXT_PUBLIC_NETWORK_RPC_URL}
      - NEXT_PUBLIC_FEATURED_NETWORKS=${NEXT_PUBLIC_FEATURED_NETWORKS}
      - HOSTNAME=0.0.0.0
    networks:
      - proxy-network
      - default   
    labels:
      caddy: "chain-${CHAINWEB_CHAIN_ID}.${BASE_EXPLORER_DOMAIN}"
      caddy.reverse_proxy: "{{ upstreams 3000 }}"
      caddy.tls: internal
      caddy.handle_path: "/visualizer/*"
      caddy.handle_path.0_rewrite: "* {uri}"
      caddy.handle_path.0_reverse_proxy: "visualizer:8050"

  stats:
    depends_on:
      backend:
        condition: service_started
      create-stats-db : 
          condition: service_completed_successfully
    extends:
      file: ./services/stats.yml
      service: stats
    networks:
      - proxy-network
      - service-network 
      - default
    labels:
      caddy: chain-${CHAINWEB_CHAIN_ID}.${BASE_EXPLORER_DOMAIN}
      caddy.handle_path: "/stats/*"
      caddy.handle_path.0_rewrite: "* {uri}"
      caddy.handle_path.reverse_proxy: "{{ upstreams 8050 }}"

  user-ops-indexer:
    depends_on:
      backend:
        condition: service_started
      create-blockscout-db : 
          condition: service_completed_successfully
      create-stats-db : 
          condition: service_completed_successfully    
    restart: on-failure      
    extends:
      file: ./services/user-ops-indexer.yml
      service: user-ops-indexer
    environment:
      - USER_OPS_INDEXER__INDEXER__RPC_URL=${USER_OPS_INDEXER__INDEXER__RPC_URL}
      - USER_OPS_INDEXER__DATABASE__CONNECT__URL=${USER_OPS_INDEXER__DATABASE__CONNECT__URL}  
    networks:
      - service-network  
      - default  
